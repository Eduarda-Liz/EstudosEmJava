METODOS ESPECIAIS: 
instanciar objetos: a "chamada" dos objetos, a primeira linha que fica Caneta c1 = new Caneta();
atributo = nao tem letra maiuscula no inicio, nao tem parentesis (parametros é pra metodos)

METODOS ACESSORES/GETTERS: dao acesso a uma determinada coisa. Dificulta o acesso direto.
o metodo getter possui o acesso direto a informacao, evitando que os objetos possuem esse acesso.
como chamar: c1.getTotalDocumentos(). Geralmente são publicos.

METODOS MODIFICADORES/MUTANTES/SETTERS: modificam coisas que estao dentro do objeto, sem que conceda acesso direto ao atributo
c1.setTotalDocumento(doc) normalmente ele precisa de um parametro pra funcionar. Mais abistrato. Geralmente são publicos.

METODO CONSTRUTOR/CONSTRUCT: sempre que instanciar um objeto, ele vai executar o comando do metodo construtor
define um padrao para todo item criado naquela classe. O objeto deve ser declarado com a quantidade de parametros exigida no construct

AULA 5:

transformar conta corrente em um objeto (historinha do jubileu e creuza): idealizar uma classe de uma conta de banco.
tipo de conta, numero da conta, nome do dono, saldo, status (aberta ou n) - atributos
abrir conta, fechar, depositar, sacar, pagar uma mensalidade - metodos

ContaBanco
---------------
+ numConta
# tipo: 2 valores, cc ou cp
- dono
- saldo
- status (aberta ou fechada)
---------------
+ abrirConta(): mudo o status para true. Preciso dizer que tipo de conta é. Se for cc comeca com 50 se for cp comeca com 150
+ fecharConta(): nao pode ter dinheiro nem debito
+ depositar(): tem que estar aberta
+ sacar(): tenho que ter saldo e precisa estar aberta
+ pagarMensal(): desconto direto do saldo. CC 12 reais, cp 20 reais de mensalidade
metodos ESPECIAIS - pra cada atributo temos um getter e setter.
    getnumConta()
    setnumConta()
    getTipo()
    setTipo()
    getDono()
    setDono()
    getSaldo()
    setSaldo()
    getStatus()
    setStatus()
Metodo Construtor: sempre que criar uma conta o status fica como false e o saldo fica com 0

PILARES DA POO:
Encapsulamento (abstraçao), Herança e Polimorfismo.

Encapsulamento: capsula (pilha). A capsula serve como uma proteção de duplo sentido. Padronização. Protege o usuario do codigo e o codigo doo usuario(programador)
Ocultar partes independentes da implementação, permitindo construir partes invisiceis ao mundo exterior. Não precisa saber o que há na arte interna de uma pilha, apenas como funciona (gera nergia)

Não entra na capsula, apenas troca mensagens (ação). Um bom objeto encapsulado possui uma interface bem definida.

interface: contato com o mundo exterior, qeu se define o que pode ser feito com o objeto desta classe. Comunicação com o meio externo.
Encapsular não é obrigatorio, mas é uma boa prática para produzir classes mais eficientes.

Vatagens: 
1 - tornar mudanças invisiveis.
2 - Facilitar a reutilização do código. Encapsulamento profundo mantém o padrão.
3 - Reduzir efeitos colaterais. Um software não encapsulado pode ser destruido por um programador

Como encapsular? Garantir a segurança (capa/capsula protegida). Identificação dos botoes
Exemplo: Carro. Nõ precisa saber o funcionamento interno para usar o Carro, fica disponível apenas a interface.

---------------------------
<<interface>> (apenas possui metodo, não possui atributos)
Controlador
---------------------------
+ligar()
+desligar()
+abrirMenu()
+fecharMenu()                 
+maisVolume()
+menosVolume()
+ligarMudo()
+desligarMudo()
+play()
+pause()
--------------------------
Metodos abstratos: não vai ser desenvolvido na interface, apenas diz a existencia daquele metodo. Apenas a reação.
A ção de aumentar um volume é a mesma pra diversos aparelhos, mas a implementação é diferente (se não, varios aumentariam ao mesmo tempo)
-----------------------
ControleRemoto (setinha pontilhada com triangulo emplementa uma interface, usando os metodos da interface)
-----------------------
-volume
-ligado
-tocando
------------------------
+ligar()
+desligar()
+abrirMenu()
+fecharMenu()                 
+maisVolume()
+menosVolume()
+ligarMudo()
+desligarMudo()
+play()
+pause()
[colocar metodos especiais nos atributos, getters e setters]
setVolume()
getVOlume()
setLigado()
getLigado()
setTocando()
getTocando()

Aula 08: AGREGAÇÃO

criar uma classe para os dois lutadores poderem luatem entre si (os dois precisam ter os mesmos atributos).

------------------
Luta
------------------
-desafiado:Lutador (o tipo deles não é String, pois eles já existem, são instancias)
-desafiante
-rounds
-aprovada
-----------------
+marcarLuta()
+lutar()
-----------------

REPRESENTAÇÃO BASICA^

Existe uma ligação entre as duas, então representa com uma linha slida com um losango na ponta.

disputa> 

colocar MULTIPLICIDADE: cada lutador pode participar de quantas lutas? "0..*"
Cada luta, pode existir quantos lutadores? "*"

diagrama de classes contém dados e funções.
A Agregação é conhecida pelo tipo "tem um", como se fosse "tem um lutador"

se eu utilizo uma instancia, um tipo abstrato de dados, eu posso utilizar tdos os metodos daquela classe

REGRAS:

1 - SÓ PODE SER MARCADA POR LUTADORES DA MESMA CATEGORIA;
2 - O DESAFIADO E O DESAFIANTE PRECISAM SER PESSOAS DIFERENTES;
3 - SÓ PODE ACONTECER SE ESSA LUTA TIVER APROVADA;
4 - SÓ PODE TER COMO RESULTADO A VITÓRIA DE UM DOS LUTADORES OU EMPATE;

Leva anos pra construir um personagem na animação, depois é bem mais fácil pra fazer o personagem se mexer. É assim que a programação orientada a objetos funciona.

AULA 10: Herança
Permite basear uma nova classe na definição de uma outra classe previamente existente

classe X estende Y -> exemplo da classe Pessoa, que a classe Aluno herda os atributos + informações específicas
reduz a "repetição" de informações em várias classes (quando tem informação comum entre as classes).


AULA 11: uma classe pode ser SUPERCLASSE ou SUBCLASSE dependendo do "ponto de vista". Uma classe progenitora tbm pode ser uma subclasse.
toda subclasse herda TODO O CONTEUDO da sua superclasse (mesmo que não esteja disponivel -, +, #).

Quando tem uma arvore que não tem progenitora ("mae") ela é chamada de RAIZ (como se fosse uma arvore de cabeça pra baixo).
a parte de baixo (a subclasse não tem filhas) são chamadas de FOLHA.

Descendentes: para definir um descendente não é considerado a "mae", apenas "netos" ou mais.
Ancestral: não pode ser ancestral das suas próprias filhas, apenas dos netos pra baixo.

ESPECIALIZAÇÃO: quando percorre a arvore de CIMA pra BAIXO.
GENERALIZAÇÃO: quando percorre a arvore de BAIXO pra CIMA.

TIPOS DE HERANÇA:
1 - Hernaça de Implementação (herança pobre). Não adiciona atributo e metodo nenhum.
2 - Herança para DIferença (mais completa). Adiciona metodos e/ou atributos

classe genérica é chamada de Classe Abstrata.

vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
ABSTRATO E FINAL
funções diferentes se método e classe.

CLASSE ABSTRATA: Não pode ser instanciada, só pode servir como progenitora. NÃO PODE GERAR OBJETO
METODO ABSTRATO: Um metodo declado mas não implementado na progenitora.
CLASSE FINAL: Não pode ser herdada por outra classe, precisa ser obrigatoriamente folha (esteril)
METODO FINAL: Não pode ser sobrescrito pelas suas subclasses. Precisa ser obrigatoriamente herdado.

MUITO IMPORTANTE!!!!!!!!! ^^^^^^^^^^^^^^^^^^^^^^^^

A sobreposição de metodos permite que o metodo se comporte diferente naquele objeto em específico

AULA 12 - polimorfismo, último pilar da POO

Polimorfismo: permite que um mesmo nome represente varios comportamentos diferentes
Assinatura do metodo: QUANTIDADE E TIPO dos parametros.

exemplo:

public double calcMedia(double n1, double n2);
public int calcMedia(double v1, double v2);

O tipo de retorno não entra nos conceito de assinatura, então a assinatura acima é igual.

public double calcMedia(double v1, double v2, double v3);

essa assinatura por exemplo, é diferente, pois tem uma quantidade diferente de parametros da referencia. Não é a mesma assinatura.

1 - SOBREPOSIÇÃO: é quando "sobrepomos" um método para, naquela classe em especifico, tenha um comportamento diferente quando o método é chamado.

lembrar: classe abstrata não pode ser instanciada 
chamar um metodo com mesmo nome e ter resultado diferente.
polimorfismo de sobreposição: acontece quando substituimos um metodo de uma superclasse na sua 
subclasse, usando a mesma assinatura.

um metodo pode ser sobreposto varias vezes, sempre vai valer a "ultima" sobreposição